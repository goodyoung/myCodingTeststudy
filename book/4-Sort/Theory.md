# Sort Algorithm
> 정렬(sorting)이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.
---
## 선택 정렬
> **가장 작은 데이터**를 선택해 맨 앞에 있는 데이터랑 바꾸는 과정을 반복하는 정렬.
> 
- 선택 정렬의 시간 복잡도
    - 선택 정렬은 N-1 번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
따라서 시간 복잡도는 ```N+(N-1)+(N-2) + ... + 2``` -> ```O(N^2)``` 이다.
---

## 삽입 정렬
> 특정한 데이터를 적절한 위치에 '삽입'한다.
> 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬이 되어 있다고 가정한다.

- 삽입 정렬의 시간 복잡도
  - 삽입 정렬의 시간 복잡도는 O(N^2)인데 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다. 최선의 경우 O(N)이다. 거의 정렬이 되어 있는 입력이 주어지는 문제라면 퀵정렬 등의 여타 정렬 알고리즘을 이용하는 것 보다 삽입 정렬을 이용하는 것이 정답 확률을 더 높일 수있다.

---
## 퀵 정렬
> 기준을 설정한 다음 그 수를 기준으로 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

- 퀵 정렬의 시간 복잡도
  - 퀵 정렬의 시간 복잡도는 평균 O(NlogN)이다. 최악의 경우에 O(N^2)이다.
  - 삽입 정렬과는 다르게 '이미 데이터가 정렬되어 있는 경우'에는 매우 느리게 동작한다.

---

## 계수 정렬
> 특정한 조건(데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때)이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
> 특정 범위의 숫자 공간을 만들고 거기에 개수를 추가하여 정렬하는 식이다.

- 계수 정렬의 시간 복잡도
  - 계수 정렬의 시간 복잡도는 데이터의 개수가 N, 최대값이 K일 때 최악의 경우에도 O(N+K)를 보장한다.
- 계수 정렬의 공간 복잡도
  - 0과 999,999만 존재할 때 리스트의 크기가 100만개가 되도록 선언해야 한다.
  - 따라서 일반적인 경우, 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리하다.
---